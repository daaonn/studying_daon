### 문제. SQL Project Planning
https://www.hackerrank.com/challenges/sql-projects/problem?isFullScreen=true


* TABLE : PROJECTS
* END_DATE - START_DATE = 1
* END_DATE가 연속적이면 같은 프로젝트
* 완료된 서로 다른 프로젝트의 시작일, 종료일
* 프로젝트 수행 일수를 기준으로 ASC, 시작일 ASC


***LAG***
: 바로 이전 행 가져오기

```SQL
-- 연속된 날짜 구간 묶기
-- 1. END_DATE 기준으로 정렬
-- 2. 연속되지 않는 지점 찾기
-- 3. 그 구간의 첫 START_DATE와 마지막 END_DATE 묶기

WITH T AS (
  SELECT
    CASE
      WHEN LAG(END_DATE) OVER (ORDER BY END_DATE) IS NULL THEN 1 -- 비교할 이전 날짜가 없으니까 무조건 새로운 플젝의 시작
      WHEN END_DATE - LAG(END_DATE) OVER (ORDER BY END_DATE)) = 1 -- 연속이면
      THEN '0' 
      ELSE '1' -- 연속이 끊기면 1
    END AS STATUS
  FROM PROJECTS),
G AS (
  SELECT START_DATE, END_DATE, SUM(STATUS) OVER (ORDER BY END_DATE) AS P_ID -- 프로젝트 시작할 때마다 1씩 증가시키는 카운
  FROM T)

SELECT
  MIN(START_DATE) AS S
  MAX(END_DATE) AS E
FROM G
GROUP BY P_ID
ORDER BY DATEDIFF(MAX(END_DATE), MIN(START_DATE)) ASC, MIN(START_DATE) ASC;
```


```SQL
WITH base AS (
  SELECT
    Start_Date,
    End_Date,
    LAG(End_Date) OVER (ORDER BY End_Date) AS prev_end
  FROM Projects
),
flagged AS (
  SELECT
    Start_Date,
    End_Date,
    CASE
      WHEN prev_end IS NULL THEN 1
      WHEN End_Date - prev_end = 1 THEN 0
      ELSE 1
    END AS new_project
  FROM base
),
grouped AS (
  SELECT
    Start_Date,
    End_Date,
    SUM(new_project) OVER (ORDER BY End_Date) AS project_id
  FROM flagged
)
SELECT
  MIN(Start_Date),
  MAX(End_Date)
FROM grouped
GROUP BY project_id
ORDER BY
  MAX(End_Date) - MIN(Start_Date),
  MIN(Start_Date);
```
* OVER(ORDER BY ...)의 역할 : 모든 행 그대로 유지 👉 대신 “각 행마다 계산 결과”를 붙여줌
