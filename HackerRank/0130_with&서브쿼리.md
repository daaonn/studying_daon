### 문제. Occupations


https://www.hackerrank.com/challenges/occupations/problem?isFullScreen=true


Pivot the Occupation column in OCCUPATIONS so that **each Name is sorted alphabetically** and **displayed underneath its corresponding Occupation**. The output should consist of four columns (Doctor, Professor, Singer, and Actor) in that specific order, with their respective names listed alphabetically under each column.

Note: Print NULL when there are no more names corresponding to an occupation.

[Input Format]

The OCCUPATIONS table is described as follows:


<div align="center">
<img width="468" height="231" alt="image" src="https://github.com/user-attachments/assets/ca5c0c4b-19c4-4cca-8f0c-7dfeae4ee525" />
</div>


Occupation will only contain one of the following values: Doctor, Professor, Singer or Actor.

*Sample Output*
```sql
Jenny    Ashley     Meera  Jane
Samantha Christeen  Priya  Julia
NULL     Ketty      NULL   Maria
```


<풀이>


**1. 직업별로 이름 정렬**
```sql
select name
from occupations
where occupation = 'Doctor'
order by name;
```


**2. 각 직업별로 나온 리스트에 번호 매기기**
```sql
select name,
  row_number () over (partition by occupation order by name) as rn
from occupations
where occupation in ('Doctor', 'Professor', 'Singer', 'Actor');
```
ROW_NUMBER : 그룹 안에서 순서 매기기 라잌 '번호표 뽑기'
* partition by - 그룹 기준
* order by - 정렬 기준


**최종 풀이**
```sql
-- rn을 기준으로 가로로 합치기
with ranked as ( -- 1. ranked라는 임시 테이블 생성 (cte)
  select name, occupation,
    row_number () over (partition by occupation order by name) as rn
  from occupations
)
select -- 2. 임시 테이블을 이용해 최종 피벗 결과 생성
  max(case when occupation = 'Doctor' then name end) as doctor, -- max : 값을 하나만 뽑아줌
  max(case when occupation = 'Professor' then name end) as professor,
  max(case when occupation = 'Singer' then name end) as singer,
  max(case when occupation = 'Actor' then name end) as actor
from ranked
group by rn
order by rn;
```


* with = '이름 붙인 서브쿼리' (저장하는 건 아님)
```sql
---서브쿼리
SELECT ..
FROM (
  SELECT
  FROM occupations
) ranked
...

---WITH -- 디버깅하기 좋음
WITH ranked AS (SELECT ...)
SELECT ...
FROM ranked;
```


> MySQL 5.7 기준으로 풀이
```sql
-- 서브쿼리 이용하기
SELECT
  MAX(CASE WHEN occupation='Doctor' THEN name END) AS Doctor,
  MAX(CASE WHEN occupation='Professor' THEN name END) AS Professor,
  MAX(CASE WHEN occupation='Singer' THEN name END) AS Singer,
  MAX(CASE WHEN occupation='Actor' THEN name END) AS Actor
FROM (
  SELECT
    o1.name,
    o1.occupation,
    (
    -- 직업별로 이름 순서대로 1, 2, 3 ... 번호 매기기
      SELECT COUNT(*)
      FROM occupations o2 -- 나와 같은 직업의 모든 사람
      WHERE o2.occupation = o1.occupation -- 1. 같은 직업 그룹만 비교
        AND o2.name <= o1.name -- 2. 현재 사람보다 '이름이 사전순으로 작거나 같은 사람'의 수 카운트
        -- 이때, 첫 번째 사람의 rn이 1이 되어야 함 >> 자기 자신에 대한 비교도 포함해야 
    ) AS rn
  FROM occupations o1 -- 내가 계산하려는 사람
) t
GROUP BY rn
ORDER BY rn;
```


> ex ) rn = 1 그룹
<div align="center">
<img width="441" height="200" alt="image" src="https://github.com/user-attachments/assets/13cb81d9-5403-44e1-b03e-0f4ac79a0d1b" />
</div>


* max >> null값 제외 jenny를 뽑게 됨


*<전체 구조 요약>*


1. occupation + name으로 rn(순번) 만들기
2. 같은 rn끼리 묶기 (group by)
3. 직업별 열 만들기 (case when)
4. max로 값 하나만 뽑기


